# 小程序消息通知系统 - 快速使用指南

## 1. 快速开始

### 1.1 执行数据库脚本

```bash
# 连接到MySQL数据库
mysql -u root -p your_database

# 执行升级脚本
source jiayou-admin-service/src/main/resources/sql/8.notification_system_enhancement.sql
```

### 1.2 配置微信小程序

在 `application.yml` 中配置微信小程序参数：

```yaml
wechat:
  miniapp:
    appid: your_wechat_appid
    secret: your_wechat_secret

notification:
  in-app:
    enabled: true
  wechat:
    enabled: true
  sms:
    enabled: true
  retention-days: 30
```

### 1.3 获取微信订阅消息模板

1. 登录微信公众平台：https://mp.weixin.qq.com
2. 进入"功能" -> "订阅消息"
3. 选择公共模板库中的模板或自定义模板
4. 获取模板ID，更新数据库中的 `wechat_subscribe_template` 表

---

## 2. 常用场景示例

### 2.1 发送订单接单通知（用户端）

```java
@Service
public class OrderServiceImpl {
    
    @Autowired
    private NotificationService notificationService;
    
    /**
     * 阿姨接单后发送通知
     */
    public void notifyOrderAccepted(Order order, Staff staff) {
        // 准备模板数据
        Map<String, String> templateData = new HashMap<>();
        templateData.put("thing1", order.getOrderNo());  // 订单号
        templateData.put("thing2", staff.getName());      // 阿姨姓名
        templateData.put("character_string3", order.getVerificationCode());  // 核验码
        templateData.put("date4", order.getServiceTime().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm")));
        
        // 发送通知
        notificationService.sendOrderNotification(
            order.getUserId(),           // 用户ID
            null,                        // 阿姨ID（用户端不需要）
            order.getId(),               // 订单ID
            "阿姨已接单",                  // 标题
            String.format("订单%s已被%s接单，核验码：%s，服务时间：%s", 
                order.getOrderNo(), 
                staff.getName(), 
                order.getVerificationCode(),
                order.getServiceTime().format(DateTimeFormatter.ofPattern("MM月dd日 HH:mm"))),
            "ORDER_ACCEPTED",            // 微信模板编码
            templateData                 // 模板数据
        );
    }
}
```

### 2.2 发送新订单通知（阿姨端）

```java
@Service
public class OrderServiceImpl {
    
    @Autowired
    private NotificationService notificationService;
    
    /**
     * 用户下单后通知附近阿姨
     */
    public void notifyNearbyStaff(Order order, List<Staff> nearbyStaffList) {
        for (Staff staff : nearbyStaffList) {
            // 准备模板数据
            Map<String, String> templateData = new HashMap<>();
            templateData.put("thing1", order.getServiceName());  // 服务名称
            templateData.put("date2", order.getServiceTime().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm")));
            templateData.put("thing3", order.getAddress());      // 服务地址
            
            // 发送通知
            NotificationSendRequest request = new NotificationSendRequest();
            request.setStaffId(staff.getId());
            request.setTitle("附近有新订单");
            request.setContent(String.format("服务类型：%s，服务时间：%s，快去抢单！", 
                order.getServiceName(),
                order.getServiceTime().format(DateTimeFormatter.ofPattern("MM月dd日 HH:mm"))));
            request.setType(NotificationType.ORDER.name());
            request.setPriority(NotificationPriority.HIGH.name());
            request.setRelatedType("ORDER");
            request.setRelatedId(order.getId());
            request.setPushInApp(true);
            request.setPushWechat(true);
            request.setPushSms(false);
            request.setWechatTemplateCode("NEW_ORDER");
            request.setWechatTemplateData(templateData);
            
            // 设置跳转参数
            Map<String, Object> jumpParams = new HashMap<>();
            jumpParams.put("orderId", order.getId());
            request.setJumpParams(jumpParams);
            request.setJumpUrl("/pages/order/detail");
            
            notificationService.sendNotification(request);
        }
    }
}
```

### 2.3 发送支付成功通知

```java
@Service
public class PaymentServiceImpl {
    
    @Autowired
    private NotificationService notificationService;
    
    /**
     * 支付成功后发送通知
     */
    public void notifyPaymentSuccess(Order order, PaymentRecord payment) {
        // 准备模板数据
        Map<String, String> templateData = new HashMap<>();
        templateData.put("amount1", payment.getAmount().toString());  // 支付金额
        templateData.put("thing2", order.getOrderNo());               // 订单号
        templateData.put("date3", payment.getPayTime().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm")));
        
        // 发送通知
        NotificationSendRequest request = new NotificationSendRequest();
        request.setUserId(order.getUserId());
        request.setTitle("支付成功");
        request.setContent(String.format("订单%s支付成功，金额%.2f元", 
            order.getOrderNo(), payment.getAmount()));
        request.setType(NotificationType.PAYMENT.name());
        request.setPriority(NotificationPriority.MEDIUM.name());
        request.setRelatedType("PAYMENT");
        request.setRelatedId(payment.getId());
        request.setPushInApp(true);
        request.setPushWechat(true);
        request.setPushSms(false);
        request.setWechatTemplateCode("PAYMENT_SUCCESS");
        request.setWechatTemplateData(templateData);
        
        notificationService.sendNotification(request);
    }
}
```

### 2.4 发送服务提醒通知

```java
@Service
@Slf4j
public class ServiceReminderTask {
    
    @Autowired
    private NotificationService notificationService;
    
    @Autowired
    private OrderMapper orderMapper;
    
    /**
     * 定时任务：服务前2小时提醒
     */
    @Scheduled(cron = "0 */30 * * * ?")  // 每30分钟执行一次
    public void sendServiceReminder() {
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime reminderTime = now.plusHours(2);
        
        // 查询2小时后开始的订单
        LambdaQueryWrapper<Order> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(Order::getStatus, "ACCEPTED")
               .between(Order::getServiceTime, now, reminderTime);
        
        List<Order> orders = orderMapper.selectList(wrapper);
        
        for (Order order : orders) {
            try {
                // 准备模板数据
                Map<String, String> templateData = new HashMap<>();
                templateData.put("thing1", order.getServiceName());
                templateData.put("date2", order.getServiceTime().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm")));
                templateData.put("thing3", order.getAddress());
                
                // 发送给用户
                NotificationSendRequest userRequest = new NotificationSendRequest();
                userRequest.setUserId(order.getUserId());
                userRequest.setTitle("服务即将开始");
                userRequest.setContent(String.format("您的%s服务将于%s开始，请做好准备", 
                    order.getServiceName(),
                    order.getServiceTime().format(DateTimeFormatter.ofPattern("MM月dd日 HH:mm"))));
                userRequest.setType(NotificationType.SERVICE.name());
                userRequest.setPriority(NotificationPriority.HIGH.name());
                userRequest.setRelatedType("ORDER");
                userRequest.setRelatedId(order.getId());
                userRequest.setPushInApp(true);
                userRequest.setPushWechat(true);
                userRequest.setPushSms(true);
                userRequest.setWechatTemplateCode("SERVICE_STARTING");
                userRequest.setWechatTemplateData(templateData);
                
                notificationService.sendNotification(userRequest);
                
                // 发送给阿姨
                if (order.getStaffId() != null) {
                    NotificationSendRequest staffRequest = new NotificationSendRequest();
                    staffRequest.setStaffId(order.getStaffId());
                    staffRequest.setTitle("服务即将开始");
                    staffRequest.setContent(String.format("订单%s即将开始，请准时到达服务地址", 
                        order.getOrderNo()));
                    staffRequest.setType(NotificationType.SERVICE.name());
                    staffRequest.setPriority(NotificationPriority.HIGH.name());
                    staffRequest.setRelatedType("ORDER");
                    staffRequest.setRelatedId(order.getId());
                    staffRequest.setPushInApp(true);
                    staffRequest.setPushWechat(true);
                    staffRequest.setPushSms(true);
                    staffRequest.setWechatTemplateCode("SERVICE_STARTING");
                    staffRequest.setWechatTemplateData(templateData);
                    
                    notificationService.sendNotification(staffRequest);
                }
                
            } catch (Exception e) {
                log.error("发送服务提醒失败: orderId={}", order.getId(), e);
            }
        }
    }
}
```

---

## 3. 小程序前端集成

### 3.1 用户订阅消息授权（下单时）

```javascript
// pages/order/create.js
export default {
  methods: {
    // 创建订单
    async createOrder() {
      try {
        // 1. 先请求订阅授权
        await this.requestSubscribe();
        
        // 2. 创建订单
        const res = await uni.$http.post('/user/order', this.orderData);
        
        if (res.code === 200) {
          uni.showToast({ title: '下单成功' });
          uni.redirectTo({ url: '/pages/order/detail?id=' + res.data.id });
        }
      } catch (error) {
        console.error('创建订单失败:', error);
        uni.showToast({ title: '下单失败', icon: 'none' });
      }
    },
    
    // 请求订阅授权
    async requestSubscribe() {
      try {
        const res = await uni.requestSubscribeMessage({
          tmplIds: [
            'YOUR_TEMPLATE_ID_1',  // 订单接单通知
            'YOUR_TEMPLATE_ID_2',  // 服务开始提醒
            'YOUR_TEMPLATE_ID_3'   // 服务完成通知
          ]
        });
        
        console.log('订阅结果:', res);
        
        // 保存授权结果到后端
        for (let tmplId in res) {
          if (res[tmplId] === 'accept') {
            await uni.$http.post('/notification/subscribe', {
              templateId: tmplId,
              templateCode: this.getTemplateCode(tmplId)
            });
          }
        }
        
      } catch (error) {
        console.error('请求订阅授权失败:', error);
        // 即使授权失败也继续下单流程
      }
    },
    
    // 根据模板ID获取模板编码
    getTemplateCode(templateId) {
      const mapping = {
        'YOUR_TEMPLATE_ID_1': 'ORDER_ACCEPTED',
        'YOUR_TEMPLATE_ID_2': 'SERVICE_STARTING',
        'YOUR_TEMPLATE_ID_3': 'ORDER_COMPLETED'
      };
      return mapping[templateId] || templateId;
    }
  }
};
```

### 3.2 消息中心页面

```vue
<!-- pages/notification/index.vue -->
<template>
  <view class="notification-page">
    <!-- 消息统计卡片 -->
    <view class="stat-card">
      <view class="stat-info">
        <text class="stat-count">{{ stat.unreadCount }}</text>
        <text class="stat-label">未读消息</text>
      </view>
      <button class="btn-mark-all" @click="markAllAsRead">全部已读</button>
    </view>

    <!-- 消息类型选项卡 -->
    <view class="tabs">
      <view 
        v-for="tab in tabs" 
        :key="tab.type"
        :class="['tab-item', { active: activeType === tab.type }]"
        @click="switchTab(tab.type)"
      >
        <text>{{ tab.name }}</text>
        <view v-if="tab.unreadCount > 0" class="badge">{{ tab.unreadCount }}</view>
      </view>
    </view>

    <!-- 消息列表 -->
    <scroll-view 
      scroll-y 
      class="message-list"
      @scrolltolower="loadMore"
    >
      <view 
        v-for="item in messageList" 
        :key="item.id"
        :class="['message-item', { unread: item.status === 'UNREAD' }]"
        @click="handleMessageClick(item)"
      >
        <view class="message-main">
          <view class="message-header">
            <text class="message-title">{{ item.title }}</text>
            <text class="message-time">{{ formatTime(item.createdTime) }}</text>
          </view>
          <view class="message-content">{{ item.content }}</view>
        </view>
        <view v-if="item.status === 'UNREAD'" class="unread-dot"></view>
      </view>

      <!-- 加载更多 -->
      <view v-if="hasMore" class="load-more">加载中...</view>
      <view v-else-if="messageList.length > 0" class="no-more">没有更多了</view>

      <!-- 空状态 -->
      <view v-if="messageList.length === 0 && !loading" class="empty-state">
        <image src="/static/empty.png" class="empty-icon" />
        <text class="empty-text">暂无消息</text>
      </view>
    </scroll-view>
  </view>
</template>

<script>
import dayjs from 'dayjs';
import relativeTime from 'dayjs/plugin/relativeTime';
import 'dayjs/locale/zh-cn';

dayjs.extend(relativeTime);
dayjs.locale('zh-cn');

export default {
  data() {
    return {
      activeType: '',
      stat: {
        unreadCount: 0,
        orderUnreadCount: 0,
        systemUnreadCount: 0,
        otherUnreadCount: 0
      },
      tabs: [
        { name: '全部', type: '', unreadCount: 0 },
        { name: '订单', type: 'ORDER', unreadCount: 0 },
        { name: '系统', type: 'SYSTEM', unreadCount: 0 },
        { name: '活动', type: 'ACTIVITY', unreadCount: 0 }
      ],
      messageList: [],
      page: 1,
      size: 20,
      hasMore: true,
      loading: false
    };
  },
  
  onLoad() {
    this.init();
  },
  
  // 下拉刷新
  onPullDownRefresh() {
    this.refresh();
  },
  
  methods: {
    // 初始化
    async init() {
      await this.loadStat();
      await this.loadMessageList();
    },
    
    // 刷新
    async refresh() {
      this.page = 1;
      this.hasMore = true;
      await this.init();
      uni.stopPullDownRefresh();
    },
    
    // 加载统计
    async loadStat() {
      try {
        const res = await uni.$http.get('/notification/stat');
        if (res.code === 200) {
          this.stat = res.data;
          this.tabs[0].unreadCount = res.data.unreadCount;
          this.tabs[1].unreadCount = res.data.orderUnreadCount;
          this.tabs[2].unreadCount = res.data.systemUnreadCount;
          this.tabs[3].unreadCount = res.data.otherUnreadCount;
          
          // 更新TabBar徽标
          if (res.data.unreadCount > 0) {
            uni.setTabBarBadge({
              index: 2,  // 消息中心的TabBar索引
              text: String(res.data.unreadCount)
            });
          } else {
            uni.removeTabBarBadge({ index: 2 });
          }
        }
      } catch (error) {
        console.error('加载统计失败:', error);
      }
    },
    
    // 加载消息列表
    async loadMessageList() {
      if (this.loading) return;
      
      this.loading = true;
      try {
        const res = await uni.$http.get('/notification/list', {
          type: this.activeType,
          page: this.page,
          size: this.size
        });
        
        if (res.code === 200) {
          const newList = res.data.records || [];
          
          if (this.page === 1) {
            this.messageList = newList;
          } else {
            this.messageList = [...this.messageList, ...newList];
          }
          
          this.hasMore = newList.length >= this.size;
        }
      } catch (error) {
        console.error('加载消息列表失败:', error);
        uni.showToast({ title: '加载失败', icon: 'none' });
      } finally {
        this.loading = false;
      }
    },
    
    // 加载更多
    loadMore() {
      if (!this.hasMore || this.loading) return;
      this.page++;
      this.loadMessageList();
    },
    
    // 切换选项卡
    switchTab(type) {
      if (this.activeType === type) return;
      this.activeType = type;
      this.page = 1;
      this.hasMore = true;
      this.messageList = [];
      this.loadMessageList();
    },
    
    // 点击消息
    async handleMessageClick(item) {
      try {
        // 标记为已读
        if (item.status === 'UNREAD') {
          await uni.$http.put(`/notification/${item.id}/read`);
          
          // 更新本地数据
          item.status = 'READ';
          this.stat.unreadCount = Math.max(0, this.stat.unreadCount - 1);
          
          // 更新类型统计
          if (item.type === 'ORDER') {
            this.stat.orderUnreadCount = Math.max(0, this.stat.orderUnreadCount - 1);
          } else if (item.type === 'SYSTEM') {
            this.stat.systemUnreadCount = Math.max(0, this.stat.systemUnreadCount - 1);
          } else {
            this.stat.otherUnreadCount = Math.max(0, this.stat.otherUnreadCount - 1);
          }
          
          this.updateTabBadge();
        }
        
        // 跳转到相关页面
        if (item.jumpUrl) {
          const params = item.jumpParams || {};
          const query = Object.keys(params)
            .map(key => `${key}=${params[key]}`)
            .join('&');
          
          uni.navigateTo({
            url: `${item.jumpUrl}${query ? '?' + query : ''}`
          });
        }
        
      } catch (error) {
        console.error('处理消息点击失败:', error);
      }
    },
    
    // 全部已读
    async markAllAsRead() {
      try {
        await uni.$http.put('/notification/read-all', {
          type: this.activeType
        });
        
        uni.showToast({ title: '操作成功' });
        
        // 刷新数据
        this.refresh();
        
      } catch (error) {
        console.error('全部已读失败:', error);
        uni.showToast({ title: '操作失败', icon: 'none' });
      }
    },
    
    // 更新TabBar徽标
    updateTabBadge() {
      if (this.stat.unreadCount > 0) {
        uni.setTabBarBadge({
          index: 2,
          text: String(this.stat.unreadCount)
        });
      } else {
        uni.removeTabBarBadge({ index: 2 });
      }
    },
    
    // 格式化时间
    formatTime(time) {
      if (!time) return '';
      
      const now = dayjs();
      const target = dayjs(time);
      const diff = now.diff(target, 'day');
      
      if (diff === 0) {
        // 今天显示具体时间
        return target.format('HH:mm');
      } else if (diff === 1) {
        // 昨天
        return '昨天 ' + target.format('HH:mm');
      } else if (diff < 7) {
        // 一周内显示星期
        return target.format('dddd HH:mm');
      } else {
        // 其他显示日期
        return target.format('MM-DD HH:mm');
      }
    }
  }
};
</script>

<style scoped lang="scss">
.notification-page {
  min-height: 100vh;
  background-color: #f5f5f5;
}

.stat-card {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 30rpx;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: #fff;
  
  .stat-info {
    display: flex;
    flex-direction: column;
  }
  
  .stat-count {
    font-size: 48rpx;
    font-weight: bold;
    line-height: 1;
    margin-bottom: 10rpx;
  }
  
  .stat-label {
    font-size: 28rpx;
    opacity: 0.9;
  }
  
  .btn-mark-all {
    padding: 12rpx 24rpx;
    background: rgba(255, 255, 255, 0.2);
    color: #fff;
    border: 1rpx solid rgba(255, 255, 255, 0.5);
    border-radius: 40rpx;
    font-size: 26rpx;
  }
}

.tabs {
  display: flex;
  background: #fff;
  padding: 0 30rpx;
  
  .tab-item {
    position: relative;
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 30rpx 0;
    font-size: 30rpx;
    color: #666;
    
    &.active {
      color: #667eea;
      font-weight: bold;
      
      &::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 40rpx;
        height: 4rpx;
        background: #667eea;
        border-radius: 2rpx;
      }
    }
    
    .badge {
      position: absolute;
      top: 20rpx;
      right: 20%;
      min-width: 32rpx;
      height: 32rpx;
      padding: 0 8rpx;
      background: #ff4d4f;
      color: #fff;
      font-size: 20rpx;
      line-height: 32rpx;
      text-align: center;
      border-radius: 16rpx;
    }
  }
}

.message-list {
  height: calc(100vh - 300rpx);
}

.message-item {
  position: relative;
  display: flex;
  align-items: center;
  padding: 30rpx;
  margin: 20rpx 30rpx;
  background: #fff;
  border-radius: 16rpx;
  box-shadow: 0 2rpx 12rpx rgba(0, 0, 0, 0.05);
  
  &.unread {
    background: #f0f5ff;
  }
  
  .message-main {
    flex: 1;
    overflow: hidden;
  }
  
  .message-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12rpx;
  }
  
  .message-title {
    flex: 1;
    font-size: 32rpx;
    font-weight: bold;
    color: #333;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  
  .message-time {
    margin-left: 20rpx;
    font-size: 24rpx;
    color: #999;
    flex-shrink: 0;
  }
  
  .message-content {
    font-size: 28rpx;
    color: #666;
    line-height: 1.6;
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
  }
  
  .unread-dot {
    width: 16rpx;
    height: 16rpx;
    background: #ff4d4f;
    border-radius: 50%;
    margin-left: 20rpx;
    flex-shrink: 0;
  }
}

.load-more,
.no-more {
  padding: 30rpx;
  text-align: center;
  font-size: 26rpx;
  color: #999;
}

.empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 120rpx 0;
  
  .empty-icon {
    width: 200rpx;
    height: 200rpx;
    margin-bottom: 30rpx;
  }
  
  .empty-text {
    font-size: 28rpx;
    color: #999;
  }
}
</style>
```

---

## 4. 测试验证

### 4.1 单元测试示例

```java
@SpringBootTest
class NotificationServiceTest {

    @Autowired
    private NotificationService notificationService;

    @Test
    void testSendOrderNotification() {
        // 准备测试数据
        Long userId = 1L;
        Long orderId = 100L;
        String title = "测试订单通知";
        String content = "这是一条测试消息";
        String templateCode = "ORDER_ACCEPTED";
        
        Map<String, String> templateData = new HashMap<>();
        templateData.put("thing1", "TEST001");
        templateData.put("thing2", "张阿姨");
        templateData.put("character_string3", "123456");
        templateData.put("date4", "2024-10-15 14:00");
        
        // 发送通知
        notificationService.sendOrderNotification(
            userId, null, orderId, title, content, templateCode, templateData
        );
        
        // 验证消息是否创建成功
        // ...
    }

    @Test
    void testGetNotificationList() {
        Long userId = 1L;
        Page<NotificationResponse> page = notificationService.getNotificationPage(
            userId, null, null, null, 1, 10
        );
        
        assertNotNull(page);
        assertTrue(page.getTotal() >= 0);
    }
}
```

### 4.2 接口测试

使用Postman或其他API测试工具测试以下接口：

```bash
# 1. 获取消息列表
GET /notification/list?page=1&size=10
Authorization: Bearer {token}

# 2. 获取消息统计
GET /notification/stat
Authorization: Bearer {token}

# 3. 标记为已读
PUT /notification/{id}/read
Authorization: Bearer {token}

# 4. 全部已读
PUT /notification/read-all
Authorization: Bearer {token}
```

---

## 5. 常见问题

### 5.1 微信订阅消息发送失败

**问题**：微信订阅消息一直发送失败

**解决方案**：
1. 检查模板ID是否正确
2. 检查用户是否已授权订阅
3. 检查access_token是否有效
4. 查看微信公众平台的错误日志

### 5.2 消息未读数不准确

**问题**：消息未读数统计不准确

**解决方案**：
1. 检查消息状态更新是否正常
2. 检查is_deleted字段的逻辑删除是否生效
3. 刷新缓存或重新统计

### 5.3 消息推送延迟

**问题**：消息推送有明显延迟

**解决方案**：
1. 检查线程池配置是否合理
2. 增加线程池核心线程数
3. 优化数据库查询性能
4. 考虑使用消息队列（Kafka/RabbitMQ）

---

## 6. 性能优化建议

### 6.1 使用Redis缓存未读数

```java
@Service
public class NotificationCacheService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String UNREAD_COUNT_KEY = "notification:unread:";
    
    /**
     * 获取未读数（从缓存）
     */
    public Long getUnreadCount(Long userId, Long staffId) {
        String key = UNREAD_COUNT_KEY + (userId != null ? "user:" + userId : "staff:" + staffId);
        Object count = redisTemplate.opsForValue().get(key);
        return count != null ? Long.parseLong(count.toString()) : null;
    }
    
    /**
     * 更新未读数缓存
     */
    public void updateUnreadCount(Long userId, Long staffId, Long count) {
        String key = UNREAD_COUNT_KEY + (userId != null ? "user:" + userId : "staff:" + staffId);
        redisTemplate.opsForValue().set(key, count, 1, TimeUnit.HOURS);
    }
    
    /**
     * 清除未读数缓存
     */
    public void clearUnreadCount(Long userId, Long staffId) {
        String key = UNREAD_COUNT_KEY + (userId != null ? "user:" + userId : "staff:" + staffId);
        redisTemplate.delete(key);
    }
}
```

### 6.2 批量推送优化

对于需要批量推送的场景（如新订单通知多个阿姨），可以使用消息队列异步处理：

```java
@Service
public class NotificationProducerService {
    
    @Autowired
    private KafkaTemplate<String, String> kafkaTemplate;
    
    /**
     * 批量发送消息到Kafka
     */
    public void batchSendToQueue(List<NotificationSendRequest> requests) {
        for (NotificationSendRequest request : requests) {
            String message = JSONUtil.toJsonStr(request);
            kafkaTemplate.send("notification-topic", message);
        }
    }
}

@Component
@Slf4j
public class NotificationConsumer {
    
    @Autowired
    private NotificationService notificationService;
    
    @KafkaListener(topics = "notification-topic", groupId = "notification-group")
    public void consume(String message) {
        try {
            NotificationSendRequest request = JSONUtil.toBean(message, NotificationSendRequest.class);
            notificationService.sendNotification(request);
        } catch (Exception e) {
            log.error("消费消息失败", e);
        }
    }
}
```

---

## 7. 监控告警

### 7.1 监控指标

建议使用Prometheus + Grafana监控以下指标：

```java
@Component
public class NotificationMetrics {
    
    private final Counter sentCounter;
    private final Counter successCounter;
    private final Counter failureCounter;
    private final Histogram pushDuration;
    
    public NotificationMetrics(MeterRegistry registry) {
        this.sentCounter = Counter.builder("notification_sent_total")
            .description("消息发送总数")
            .register(registry);
            
        this.successCounter = Counter.builder("notification_success_total")
            .description("消息发送成功总数")
            .register(registry);
            
        this.failureCounter = Counter.builder("notification_failure_total")
            .description("消息发送失败总数")
            .register(registry);
            
        this.pushDuration = Histogram.builder("notification_push_duration")
            .description("消息推送耗时")
            .register(registry);
    }
    
    public void recordSent() {
        sentCounter.increment();
    }
    
    public void recordSuccess() {
        successCounter.increment();
    }
    
    public void recordFailure() {
        failureCounter.increment();
    }
    
    public void recordDuration(long duration) {
        pushDuration.record(duration);
    }
}
```

---

## 8. 相关文档

- [完整设计方案](./小程序消息通知系统设计方案.md)
- [微信订阅消息官方文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/subscribe-message.html)
- [家政平台需求文档](./家政平台需求文档.md)

---

## 9. 技术支持

如有问题，请联系技术支持团队或查看项目文档。

