# 小程序消息通知系统 - 代码实现说明

## 📋 实现完成清单

### ✅ 已完成的代码

#### 1. 枚举类（5个）
- ✅ `NotificationType.java` - 消息类型枚举（8种类型）
- ✅ `NotificationPriority.java` - 消息优先级枚举（HIGH/MEDIUM/LOW）
- ✅ `NotificationStatus.java` - 消息状态枚举（UNREAD/READ/DELETED）
- ✅ `PushStatus.java` - 推送状态枚举（PENDING/SUCCESS/FAILED）
- ✅ `SceneType.java` - 场景类型枚举（USER/STAFF/COMPANY）

#### 2. 实体类（4个）
- ✅ `Notification.java` - 消息通知实体（已更新，新增15个字段）
- ✅ `WechatSubscribeTemplate.java` - 微信订阅消息模板实体
- ✅ `UserSubscribeRecord.java` - 用户订阅授权记录实体
- ✅ `UserNotificationSetting.java` - 用户消息设置实体

#### 3. Mapper接口（3个新增）
- ✅ `WechatSubscribeTemplateMapper.java` - 微信模板Mapper
- ✅ `UserSubscribeRecordMapper.java` - 订阅记录Mapper
- ✅ `UserNotificationSettingMapper.java` - 消息设置Mapper

#### 4. Mapper XML（3个）
- ✅ `WechatSubscribeTemplateMapper.xml` - 微信模板SQL映射
- ✅ `UserSubscribeRecordMapper.xml` - 订阅记录SQL映射
- ✅ `UserNotificationSettingMapper.xml` - 消息设置SQL映射

#### 5. DTO类（3个）
- ✅ `NotificationSendRequest.java` - 消息发送请求
- ✅ `NotificationResponse.java` - 消息响应
- ✅ `NotificationStatResponse.java` - 消息统计响应

#### 6. Service层
- ✅ `NotificationService.java` - 消息服务接口（已更新，新增方法）
- ✅ `NotificationServiceImplNew.java` - 消息服务实现（600+行完整实现）
- ✅ `WechatService.java` - 微信服务接口
- ✅ `WechatServiceImpl.java` - 微信服务实现

#### 7. Controller层
- ✅ `NotificationController.java` - 消息通知控制器（8个接口）

#### 8. 配置类
- ✅ `AsyncConfig.java` - 异步任务配置（消息推送线程池）

#### 9. 数据库脚本
- ✅ `8.notification_system_enhancement.sql` - 数据库升级脚本

---

## 🔧 使用步骤

### 第一步：执行数据库脚本

```bash
# 连接到MySQL数据库
mysql -u root -p jiayou_db

# 执行升级脚本
source d:/haozk/jiayou/code/backend/jiayou/jiayou-admin-service/src/main/resources/sql/8.notification_system_enhancement.sql
```

### 第二步：替换Service实现类

由于保持兼容性，创建了新的实现类文件。需要手动操作：

```bash
# 备份原有实现（可选）
mv NotificationServiceImpl.java NotificationServiceImpl.java.backup

# 使用新实现
mv NotificationServiceImplNew.java NotificationServiceImpl.java
```

或者直接编辑 `NotificationServiceImpl.java`，将其内容替换为 `NotificationServiceImplNew.java` 的内容。

### 第三步：配置微信小程序参数

编辑 `jiayou-miniprogram-service/src/main/resources/application.yml`：

```yaml
# 微信小程序配置
wechat:
  miniapp:
    appid: your_wechat_appid_here
    secret: your_wechat_secret_here

# 消息通知配置
notification:
  in-app:
    enabled: true
  wechat:
    enabled: true
  sms:
    enabled: true
  retention-days: 30
```

### 第四步：获取微信订阅消息模板

1. 登录微信公众平台：https://mp.weixin.qq.com
2. 进入"功能" -> "订阅消息"
3. 选择公共模板库或自定义模板
4. 获取模板ID
5. 更新数据库 `wechat_subscribe_template` 表中的 `template_id` 字段

### 第五步：编译和启动服务

```bash
# 进入项目根目录
cd d:/haozk/jiayou/code/backend/jiayou

# 清理和编译
mvn clean package -DskipTests

# 启动小程序服务
java -jar jiayou-miniprogram-service/target/jiayou-miniprogram-service.jar
```

---

## 📡 API接口列表

### 1. 获取消息列表
```http
GET /notification/list?type=ORDER&status=UNREAD&page=1&size=10
Headers:
  userId: 123 (用户端传递)
  staffId: 456 (阿姨端传递)
```

### 2. 获取消息统计
```http
GET /notification/stat
Headers:
  userId: 123 或 staffId: 456
```

### 3. 获取消息详情
```http
GET /notification/{id}
Headers:
  userId: 123 或 staffId: 456
```

### 4. 标记消息为已读
```http
PUT /notification/{id}/read
Headers:
  userId: 123 或 staffId: 456
```

### 5. 批量标记为已读
```http
PUT /notification/batch-read
Headers:
  userId: 123 或 staffId: 456
Body:
  [1, 2, 3, 4, 5]
```

### 6. 标记全部为已读
```http
PUT /notification/read-all?type=ORDER
Headers:
  userId: 123 或 staffId: 456
```

### 7. 删除消息
```http
DELETE /notification/{id}
Headers:
  userId: 123 或 staffId: 456
```

### 8. 保存订阅授权
```http
POST /notification/subscribe?templateId=xxx&templateCode=ORDER_ACCEPTED
Headers:
  userId: 123 或 staffId: 456
```

---

## 💻 代码使用示例

### 示例1：发送订单接单通知（在OrderService中）

```java
@Service
public class OrderServiceImpl {
    
    @Autowired
    private NotificationService notificationService;
    
    /**
     * 阿姨接单后发送通知
     */
    public void handleOrderAccepted(Order order, Staff staff) {
        // 准备微信模板数据
        Map<String, String> templateData = new HashMap<>();
        templateData.put("thing1", order.getOrderNo());  // 订单号
        templateData.put("thing2", staff.getName());      // 阿姨姓名
        templateData.put("character_string3", order.getVerificationCode());  // 核验码
        templateData.put("date4", order.getServiceTime().format(
            DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm")));
        
        // 发送通知（会自动推送：站内消息 + 微信订阅消息）
        notificationService.sendOrderNotification(
            order.getUserId(),           // 用户ID
            null,                        // 阿姨ID（此处发给用户，所以为null）
            order.getId(),               // 订单ID
            "阿姨已接单",                  // 标题
            String.format("订单%s已被%s接单，核验码：%s", 
                order.getOrderNo(), 
                staff.getName(), 
                order.getVerificationCode()),
            "ORDER_ACCEPTED",            // 微信模板编码
            templateData                 // 模板数据
        );
    }
}
```

### 示例2：发送新订单通知（给附近阿姨）

```java
@Service
public class OrderServiceImpl {
    
    @Autowired
    private NotificationService notificationService;
    
    /**
     * 用户下单后通知附近阿姨
     */
    public void notifyNearbyStaff(Order order, List<Staff> nearbyStaffList) {
        for (Staff staff : nearbyStaffList) {
            // 准备微信模板数据
            Map<String, String> templateData = new HashMap<>();
            templateData.put("thing1", order.getServiceName());
            templateData.put("date2", order.getServiceTime().format(
                DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm")));
            templateData.put("thing3", order.getAddress());
            
            // 创建发送请求
            NotificationSendRequest request = new NotificationSendRequest();
            request.setStaffId(staff.getId());
            request.setTitle("附近有新订单");
            request.setContent(String.format("服务类型：%s，服务时间：%s，快去抢单！", 
                order.getServiceName(),
                order.getServiceTime().format(
                    DateTimeFormatter.ofPattern("MM月dd日 HH:mm"))));
            request.setType(NotificationType.ORDER.name());
            request.setPriority(NotificationPriority.HIGH.name());
            request.setRelatedType("ORDER");
            request.setRelatedId(order.getId());
            request.setPushInApp(true);
            request.setPushWechat(true);
            request.setPushSms(false);
            request.setWechatTemplateCode("NEW_ORDER");
            request.setWechatTemplateData(templateData);
            
            // 设置跳转参数
            Map<String, Object> jumpParams = new HashMap<>();
            jumpParams.put("orderId", order.getId());
            request.setJumpParams(jumpParams);
            request.setJumpUrl("/pages/order/detail");
            
            // 发送通知
            notificationService.sendNotification(request);
        }
    }
}
```

### 示例3：定时任务 - 服务开始前提醒

```java
@Component
@Slf4j
public class ServiceReminderTask {
    
    @Autowired
    private NotificationService notificationService;
    
    @Autowired
    private OrderMapper orderMapper;
    
    /**
     * 每30分钟执行一次，提醒2小时后开始的服务
     */
    @Scheduled(cron = "0 */30 * * * ?")
    public void sendServiceReminder() {
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime reminderTime = now.plusHours(2);
        
        // 查询2小时后开始的订单
        LambdaQueryWrapper<Order> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(Order::getStatus, "ACCEPTED")
               .between(Order::getServiceTime, now, reminderTime);
        
        List<Order> orders = orderMapper.selectList(wrapper);
        
        for (Order order : orders) {
            try {
                // 准备模板数据
                Map<String, String> templateData = new HashMap<>();
                templateData.put("thing1", order.getServiceName());
                templateData.put("date2", order.getServiceTime().format(
                    DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm")));
                templateData.put("thing3", order.getAddress());
                
                // 发送给用户
                notificationService.sendOrderNotification(
                    order.getUserId(), null, order.getId(),
                    "服务即将开始",
                    String.format("您的%s服务将于%s开始，请做好准备", 
                        order.getServiceName(),
                        order.getServiceTime().format(
                            DateTimeFormatter.ofPattern("MM月dd日 HH:mm"))),
                    "SERVICE_STARTING",
                    templateData
                );
                
                // 发送给阿姨
                if (order.getStaffId() != null) {
                    notificationService.sendOrderNotification(
                        null, order.getStaffId(), order.getId(),
                        "服务即将开始",
                        String.format("订单%s即将开始，请准时到达服务地址", 
                            order.getOrderNo()),
                        "SERVICE_STARTING",
                        templateData
                    );
                }
                
            } catch (Exception e) {
                log.error("发送服务提醒失败: orderId={}", order.getId(), e);
            }
        }
    }
}
```

---

## 🎨 小程序前端示例

### 页面1：用户下单时请求订阅授权

```javascript
// pages/order/create.js
export default {
  methods: {
    // 创建订单
    async createOrder() {
      try {
        // 1. 先请求订阅授权
        await this.requestSubscribe();
        
        // 2. 创建订单
        const res = await uni.$http.post('/user/order', this.orderData);
        
        if (res.code === 200) {
          uni.showToast({ title: '下单成功' });
          uni.redirectTo({ url: '/pages/order/detail?id=' + res.data.id });
        }
      } catch (error) {
        console.error('创建订单失败:', error);
      }
    },
    
    // 请求订阅授权
    async requestSubscribe() {
      try {
        const res = await uni.requestSubscribeMessage({
          tmplIds: [
            '模板ID1',  // 订单接单通知
            '模板ID2',  // 服务开始提醒  
            '模板ID3'   // 服务完成通知
          ]
        });
        
        // 保存授权结果到后端
        for (let tmplId in res) {
          if (res[tmplId] === 'accept') {
            await uni.$http.post('/notification/subscribe', {
              templateId: tmplId,
              templateCode: this.getTemplateCode(tmplId)
            });
          }
        }
        
      } catch (error) {
        console.error('请求订阅授权失败:', error);
        // 即使授权失败也继续下单流程
      }
    },
    
    // 模板ID映射
    getTemplateCode(templateId) {
      const mapping = {
        '模板ID1': 'ORDER_ACCEPTED',
        '模板ID2': 'SERVICE_STARTING',
        '模板ID3': 'ORDER_COMPLETED'
      };
      return mapping[templateId] || templateId;
    }
  }
};
```

### 页面2：消息中心

```javascript
// pages/notification/index.js
export default {
  data() {
    return {
      stat: { unreadCount: 0 },
      messageList: [],
      page: 1
    };
  },
  
  onLoad() {
    this.loadStat();
    this.loadMessageList();
  },
  
  methods: {
    // 加载统计
    async loadStat() {
      const res = await uni.$http.get('/notification/stat');
      if (res.code === 200) {
        this.stat = res.data;
        
        // 更新TabBar徽标
        if (res.data.unreadCount > 0) {
          uni.setTabBarBadge({
            index: 2,  // 消息Tab的索引
            text: String(res.data.unreadCount)
          });
        }
      }
    },
    
    // 加载消息列表
    async loadMessageList() {
      const res = await uni.$http.get('/notification/list', {
        page: this.page,
        size: 20
      });
      if (res.code === 200) {
        this.messageList = res.data.records;
      }
    },
    
    // 点击消息
    async handleClick(item) {
      // 标记为已读
      await uni.$http.put(`/notification/${item.id}/read`);
      
      // 跳转到详情页
      if (item.jumpUrl) {
        const params = item.jumpParams || {};
        const query = Object.keys(params)
          .map(key => `${key}=${params[key]}`)
          .join('&');
        
        uni.navigateTo({
          url: `${item.jumpUrl}${query ? '?' + query : ''}`
        });
      }
      
      // 刷新
      this.loadStat();
      this.loadMessageList();
    },
    
    // 全部已读
    async markAllAsRead() {
      await uni.$http.put('/notification/read-all');
      uni.showToast({ title: '操作成功' });
      this.loadStat();
      this.loadMessageList();
    }
  }
};
```

---

## 📝 注意事项

### 1. Service实现类替换

**重要**：需要手动将 `NotificationServiceImplNew.java` 的内容复制到 `NotificationServiceImpl.java`，或者直接重命名文件。

### 2. 微信模板ID配置

执行数据库脚本后，`wechat_subscribe_template` 表中的 `template_id` 字段是占位符 `YOUR_TEMPLATE_ID_X`，需要替换为实际的微信模板ID。

### 3. 用户身份识别

Controller中使用了 `@RequestHeader` 来获取 `userId` 和 `staffId`，需要确保：
- 用户端请求时在Header中传递 `userId`
- 阿姨端请求时在Header中传递 `staffId`

或者可以修改为使用统一的认证方式（如JWT token）。

### 4. 异步推送

微信订阅消息和短信通知是异步推送的，不会阻塞主业务。如果推送失败，会记录在 `notification` 表的推送状态字段中。

### 5. 消息清理

建议创建定时任务，定期清理过期的已读消息：

```java
@Scheduled(cron = "0 0 2 * * ?")  // 每天凌晨2点
public void cleanExpiredNotifications() {
    // 清理30天前的已读消息
    notificationMapper.deleteExpiredNotifications(30);
}
```

---

## 🐛 故障排查

### 问题1：编译错误

如果出现编译错误，检查：
1. 确保所有枚举类都已创建
2. 确保 `hutool` 依赖已引入（用于JSON工具）
3. 确保所有Mapper接口的XML文件路径正确

### 问题2：微信订阅消息发送失败

检查：
1. `application.yml` 中的 `appid` 和 `secret` 是否正确
2. 数据库中的 `template_id` 是否是实际的微信模板ID
3. 用户是否已授权订阅该模板
4. 查看日志中的微信API返回的错误信息

### 问题3：消息未读数不准确

检查：
1. 确保逻辑删除 `@TableLogic` 注解生效
2. 确保查询时过滤了 `is_deleted = 0`
3. 考虑使用Redis缓存未读数

---

## 📚 相关文档

- [小程序消息通知系统设计方案](./小程序消息通知系统设计方案.md)
- [小程序消息通知系统-快速使用指南](./小程序消息通知系统-快速使用指南.md)
- [小程序消息通知系统-文档索引](./小程序消息通知系统-文档索引.md)
- [数据库升级脚本](./jiayou-admin-service/src/main/resources/sql/8.notification_system_enhancement.sql)

---

## ✅ 实现完成

所有代码已实现完成，包括：
- ✅ 5个枚举类
- ✅ 4个实体类
- ✅ 3个Mapper接口 + 3个XML
- ✅ 3个DTO类
- ✅ Service层（接口+实现+微信服务）
- ✅ Controller层
- ✅ 配置类
- ✅ 数据库脚本

现在可以按照上述步骤进行部署和测试！🎉

